我需要使用python语言实现一款用于专业文档的翻译程序， 该翻译程序将调用OpenAI  chatgpt api进行翻译，支持多种类型的文件格式 ，如markdown,notebook,rst等等， 在翻译过程中会保持文件格式不变进行输出

基于ChatGPT 的翻译不同于传统翻译服务，通过提供相关的翻译示例，上下文信息，可以让翻译结果更加精准，因此翻译过程除了语言及文本信息，我们会配置全局及文件级别的相关信息
同时由于接口上下文长度限制，我们需要控制单词请求接口翻译的内容长度，对不同格式文件实现特定的文本分片逻辑

请帮我设计翻译程序的整体框架， 给出各个部分的抽象类设计， 目前我们已经有了以下部分：

文档分片过程， 我们已经有了如下代码， 

```python

@dataclass
class TranslateContext:
    source_lang: str
    target_lang: str
    source_path: Path
    target_path: Path
    option: Any  # Replace with actual Config type


class DocumentPiece:
    """
    文档分片对象
    """
    
    def __init__(self, text, piece_type, metadata=None):
        self.text = text
        self.type = piece_type
        self.length = len(text)
        self.metadata = metadata if metadata else {}


class DocumentProcessor(ABC):
    """
    不同格式文档继承本类来实现对应文件格式的处理逻辑 
    """

    def __init__(self, translator, context: TranslateContext):
        self.translator = translator
        self.context = context

    @abstractmethod
    def read_document(self, filepath):
        pass

    @abstractmethod
    def split_document(self, document, max_length):
        pass

    @abstractmethod
    def translate_pieces(self, pieces):
        pass

    @abstractmethod
    def combine_pieces(self, pieces):
        pass

    @abstractmethod
    def save_document(self, document):
        pass

    def process_document(self, max_length):
        document = self.read_document(self.context.source_path)
        pieces = self.split_document(document, max_length)
        translated_pieces = self.translate_pieces(pieces)
        translated_document = self.combine_pieces(translated_pieces)
        self.save_document(translated_document)

```


配置部分：
```python

@dataclass
class APIConfig:
    key: str
    base_url: str


@dataclass
class ContextOption:
    path: str
    content: str


@dataclass
class ContextConfig:
    global_context: str
    custom_context: List[ContextOption]


@dataclass
class PromptConfig:
    system: BaseMessage

    # 文件类型对应的学习小样本
    few_shot: Dict[str, List[BaseMessage]]

    def get_global_prompt(self) -> List[BaseMessage]:
        return self.get_prompt('global')

    def get_prompt(self, file_type: str) -> List[BaseMessage]:
        if self.few_shot is not None and file_type in self.few_shot and self.few_shot[file_type] is not None:
            return self.few_shot[file_type]
        return []

    def is_exist_prompt(self, type: str):
        return type in self.few_shot and self.few_shot[type] is not None


class GlobalConfig:
    prompt_template: BaseMessage


class ConfigLoader:
    """
    配置加载类，负责配置文件读取，格式转换
    """
    prompt: PromptConfig
    context: ContextConfig
    api: APIConfig
    path: str

    def __init__(self, path):
        self.path = path

    def load(self):
        p = Path(self.path)
        with open(p, 'r', encoding='utf-8') as f:
            data = yaml.safe_load(f)

        #  prompt 处理
        self._load_prompt(data['prompt'])

        # 上下文处理
        self._load_context(data['context'])

        # API配置处理
        self._load_api(data['api'])

    def _load_prompt(self, data):
        shot: Dict = {}
        for key, item in data['few-shot'].items():
            shot[key] = self._format_prompt(item)
        self.prompt = PromptConfig(system=SystemMessage(content=data['system']), few_shot=shot)

    def _load_context(self, data):
        custom_context = [ContextOption(path=item['path'], content=item['content']) for item in data['custom']]
        self.context = ContextConfig(global_context=data['global'], custom_context=custom_context)

    def _load_api(self, data):
        self.api = APIConfig(key=data['key'], base_url=data['base_url'])

    def get_context_for_file(self, file_path: str) -> str:
        matched_contexts = [option for option in self.context.custom_context if file_path.startswith(option.path)]
        if matched_contexts:
            # 从所有匹配的上下文中，返回路径最长的那个上下文
            best_match = max(matched_contexts, key=lambda option: len(option.path))
            return best_match.content
        return self.context.global_context

    def get_prompt(self):
        return self.prompt

    def get_system_prompt(self):
        return self.prompt.system

    @staticmethod
    def _format_prompt(data: list) -> List[BaseMessage]:
        res: List[BaseMessage] = []
        for item in data:
            res.append(HumanMessage(content=item['user']))
            res.append(AIMessage(content=item['llm']))
        return res
```



请结合上述代码， 给出一个整体的代码设计框架，