User
我需要实现一款python 版本的技术文档翻译程序  ，支持markdown ， notebook , rst  等多种格式文档的翻译，后续还有可能扩展文档类型;
翻译部分已完成实现，调用OpenTranslator.translate 接口即可， 由于接口存在上下文限制，因此需要每次调用翻译接口的文档长度存在限制，同时技术文档可能存在一些代码片段，不需要翻译，因此我们在处理文档时，需要对文档按照内容和长度进行分片， 请帮我提供文档分片部分的抽象和对应逻辑实现，  分片后翻译接口，翻译完成后再组合为原格式的文档 当处理文档分片和翻译接口的部分时，你可以按照以下的抽象和逻辑实现：

1. 读取源文档：首先，你需要读取源文档的内容，并将其保存到一个字符串变量中。

2. 分片文档：根据长度和内容进行文档分片。你可以定义一个函数，接受源文档和最大分片长度作为输入，并返回分片后的文档列表。可以考虑以下几个因素来进行分片：
    分片过程中，为保证分片的扩展性， 拆分好的分片应该是一个对象，有分片的类型，是否需要翻译，相关的元数据等信息便于扩展 

   - 长度限制：确定每个分片的最大长度，以确保不超过翻译接口的限制。
   - 上下文限制：如果翻译接口对上下文有限制，确保每个分片的边界不会截断上下文关系。
   - 代码片段：识别和保留代码片段，确保它们不被翻译。你可以使用正则表达式或其他文本处理技术来检测代码片段，并将其从分片中排除。
   - 内容： 如果某个分片内部没有有意义的内容，如： 如只有空白字符 则该分片不需要翻译，因此分片对象需要有一个是否翻译的属性

   分片后的文档列表应该是按顺序的，以便稍后进行翻译和重新组合。

3. 调用翻译接口：对每个分片调用翻译接口。你可以使用一个循环来遍历分片列表，并将每个分片作为参数传递给翻译函数。确保将翻译后的内容保存到另一个列表中，以便稍后重新组合。

   在调用翻译接口之前，你可能需要对分片进行一些预处理，例如去除空白行、特殊字符或格式化标记（如Markdown或RST的标记）, 并再翻译完成后还原

4. 重新组合文档：在翻译完成后，你需要将翻译后的分片重新组合成原始文档的格式。这包括将翻译后的文本插入到相应的位置，并保持原始文档的格式和结构。

   对于Markdown、Notebook和RST等格式，你可以使用现有的库或工具来解析和处理这些格式的特殊元素。在重新组合文档时，确保将代码片段重新插入到相应的位置，而不进行翻译。

翻译方法、文档合并、保存文档等过程也需要用到文件上下文相关的信息， 比如 ，目前我们已经有一个 TranslateContext 的对象


以上是一个大致的实现逻辑，具体的代码实现将涉及到具体的库和工具。你可以使用Python中的文本处理库（如`re`、`textwrap`等）、翻译API（例如OpenTranslator提供的`translate`接口）和适用于特定格式的解析器（如`markdown`、`nbformat`、`docutils`等）来实现这个功能。


以下是目前已有的实现，你需要注意这部分实现是否存在问题，并进行相应的修改或者优化

```python
from abc import ABC, abstractmethod
from dataclasses import dataclass
from pathlib import Path
from typing import Any, List

@dataclass
class TranslateContext:
    source_lang: str
    target_lang: str
    source_path: Path
    target_path: Path
    option: Any  # Replace with actual Config type

class DocumentPiece:
    def __init__(self, text, piece_type, metadata=None):
        self.text = text
        self.type = piece_type
        self.length = len(text)
        self.metadata = metadata if metadata else {}

class DocumentProcessor(ABC):

    def __init__(self, translator, context: TranslateContext):
        self.translator = translator
        self.context = context

    @abstractmethod
    def read_document(self, filepath):
        pass

    @abstractmethod
    def split_document(self, document, max_length):
        pass

    @abstractmethod
    def translate_pieces(self, pieces):
        pass

    @abstractmethod
    def combine_pieces(self, pieces):
        pass

    @abstractmethod
    def save_document(self, document):
        pass

    def process_document(self, max_length):
        document = self.read_document(self.context.source_path)
        pieces = self.split_document(document, max_length)
        translated_pieces = self.translate_pieces(pieces)
        translated_document = self.combine_pieces(translated_pieces)
        self.save_document(translated_document)

class MarkdownProcessor(DocumentProcessor):

    def read_document(self, filepath):
        with open(filepath, 'r', encoding='utf-8') as f:
            return f.read()

    def split_document(self, document: str, max_length: int) -> List[DocumentPiece]:
        lines = document.split("\n")
        pieces = []
        buffer = ""
        in_code_block = False

        for line in lines:
            stripped = line.strip()
            if stripped.startswith("```"):  # Check for start or end of a code block
                if in_code_block:  # Code block ends
                    buffer += line + "\n\n"  # Include the code block delimiter line and add a newline
                    pieces.append(DocumentPiece(buffer, "code"))
                    buffer = ""
                    in_code_block = False
                else:  # Code block starts
                    if buffer:  # Add the previous buffered text as a piece
                        pieces.append(DocumentPiece(buffer + "\n", "text"))  # add newline for consistency
                        buffer = ""
                    buffer += line + "\n"  # Include the code block delimiter line
                    in_code_block = True
            elif in_code_block:  # Inside a code block
                buffer += line + "\n"
            else:  # Normal text
                if len(buffer) + len(line) + 1 > max_length:  # +1 for the newline character
                    pieces.append(DocumentPiece(buffer + "\n", "text"))  # add newline for consistency
                    buffer = line
                else:
                    buffer += line + "\n"

        if buffer:  # Remaining text
            pieces.append(DocumentPiece(buffer + "\n", "text" if not in_code_block else "code"))

        return pieces

    def translate_pieces(self, pieces):
        translated_pieces = []
        for piece in pieces:
            if piece.type == "code":  # skip code blocks
                translated_pieces.append(piece)
            else:
                translated_text = self.translator.translate(
                    piece.text,
                    source_language=self.context.source_lang,
                    target_language=self.context.target_lang,
                    options=self.context.option
                ) + '\n'  # Ensure a newline at the end
                translated_pieces.append(DocumentPiece(translated_text, "text"))
        return translated_pieces

    def combine_pieces(self, pieces):
        return ''.join(piece.text for piece in pieces)

    def save_document(self, document):
        with open(self.context.target_path, 'w', encoding='utf-8') as f:
            f.write(document)



```